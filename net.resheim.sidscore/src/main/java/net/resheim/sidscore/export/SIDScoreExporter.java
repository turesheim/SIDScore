/**
 * Copyright (c) 2026 Torkild Ulvøy Resheim.
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 * Torkild Ulvøy Resheim <torkildr@gmail.com> - initial API and implementation
 */
package net.resheim.sidscore.export;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import net.resheim.sidscore.export.driver.DriverAddresses;
import net.resheim.sidscore.ir.FrameEventCompiler;
import net.resheim.sidscore.ir.SIDScoreIR;
import net.resheim.sidscore.sid.SidModel;

public final class SIDScoreExporter {
	public static final int BASIC_LOAD_ADDR = 0x0801;
	public static final int LOAD_ADDR = 0x1000;
	public static final int INIT_ADDR = LOAD_ADDR + 7;
	public static final int PLAY_ADDR = 0x1400;
	public static final int NOTE_FREQ_TABLE_BYTES = 128 * 2;

	private static final Path KICKASS_JAR = Path.of("lib/KickAss.jar");
	private static final double SID_CLOCK_NTSC = 1022727.0;
	private static final double SID_CLOCK_PAL = 985248.0;
	private static final int RASTER_LINE = 0;

	public static final record ProgramStats(int voiceEventBytes, int tableBytes, int noteFreqTableBytes) {
		public int scoreBytes() {
			return voiceEventBytes + tableBytes;
		}
	}

	public void writeAsm(SIDScoreIR.TimedScore score, Path outAsm) throws IOException {
		writeAsm(score, outAsm, true);
	}

	public void writeAsm(SIDScoreIR.TimedScore score, Path outAsm, boolean installIrq) throws IOException {
		StringBuilder sb = new StringBuilder();
		sb.append("// Generated by SIDScore\n");
		sb.append("// BASIC stub at $0801 -> SYS " + LOAD_ADDR + "\n");
		sb.append("// start $" + hex4(LOAD_ADDR) + " init $" + hex4(INIT_ADDR) + " play $" + hex4(PLAY_ADDR)
				+ " data (auto)\n\n");

		sb.append(".const SID_BASE = $d400\n");
		sb.append(".const V1_FREQ = SID_BASE\n");
		sb.append(".const V1_PW   = SID_BASE+2\n");
		sb.append(".const V1_CTRL = SID_BASE+4\n");
		sb.append(".const V1_AD   = SID_BASE+5\n");
		sb.append(".const V1_SR   = SID_BASE+6\n");
		sb.append(".const V2_FREQ = SID_BASE+7\n");
		sb.append(".const V2_PW   = SID_BASE+9\n");
		sb.append(".const V2_CTRL = SID_BASE+11\n");
		sb.append(".const V2_AD   = SID_BASE+12\n");
		sb.append(".const V2_SR   = SID_BASE+13\n");
		sb.append(".const V3_FREQ = SID_BASE+14\n");
		sb.append(".const V3_PW   = SID_BASE+16\n");
		sb.append(".const V3_CTRL = SID_BASE+18\n");
		sb.append(".const V3_AD   = SID_BASE+19\n");
		sb.append(".const V3_SR   = SID_BASE+20\n");
		sb.append(".const SID_FCLO = SID_BASE+21\n");
		sb.append(".const SID_FCHI = SID_BASE+22\n");
		sb.append(".const SID_RESFILT = SID_BASE+23\n");
		sb.append(".const SID_VOL = $d418\n\n");

		sb.append(".const TMP_PTR = $fb\n\n");

		sb.append("*=$0801 \"BASIC\"\n");
		sb.append(".byte $0c,$08,$0a,$00,$9e,$20,$34,$30,$39,$36,$00,$00,$00\n\n");

		sb.append("*=$" + hex4(LOAD_ADDR) + " \"INIT\"\n");
		sb.append("start:\n");
		sb.append("  jsr init\n");
		if (installIrq) {
			sb.append("  jsr install_irq\n");
		}
		sb.append("  rts\n\n");

		sb.append("init:\n");
		sb.append("  sei\n");
		sb.append("  lda #$0f\n");
		sb.append("  sta SID_VOL\n");
		sb.append("  lda #$00\n");
		sb.append("  sta SID_FCLO\n");
		sb.append("  sta SID_FCHI\n");
		sb.append("  sta SID_RESFILT\n");

		int filterRouteMask = 0;
		for (int v = 1; v <= 3; v++) {
			SIDScoreIR.TimedVoice tv = score.voices().get(v);
			SIDScoreIR.InstrumentIR instr = tv != null ? tv.instrument() : null;
			int ad = 0;
			int sr = 0;
			int pw = 0x0800;
			int pwMin = 0x0000;
			int pwMax = 0x0FFF;
			int pwSweep = 0;
			int waveBits = 0;
			int ctrlBase = 0;
			int filterModeMask = 0;
			int filterModeBits = 0;
			int filterRes = 0;
			int filterCutoff = 0;
			if (instr != null) {
				ad = ((instr.adsr().a() & 0x0f) << 4) | (instr.adsr().d() & 0x0f);
				sr = ((instr.adsr().s() & 0x0f) << 4) | (instr.adsr().r() & 0x0f);
				if (instr.pw().isPresent()) {
					pw = instr.pw().getAsInt();
				}
				if (instr.pwMin().isPresent()) {
					pwMin = instr.pwMin().getAsInt();
				}
				if (instr.pwMax().isPresent()) {
					pwMax = instr.pwMax().getAsInt();
				}
				pwSweep = instr.pwSweep();
				waveBits = waveMaskToCtrl(instr.waveMask()) & 0xF0;
				ctrlBase = waveBits | (instr.sync() ? 0x02 : 0x00) | (instr.ring() ? 0x04 : 0x00);
				filterModeMask = instr.filterModeMask();
				filterCutoff = instr.filterCutoff().orElse(0) & 0x07FF;
				filterRes = instr.filterRes().orElse(0) & 0x0F;
				if ((filterModeMask & SIDScoreIR.FilterMode.LP.mask) != 0)
					filterModeBits |= 0x10;
				if ((filterModeMask & SIDScoreIR.FilterMode.BP.mask) != 0)
					filterModeBits |= 0x20;
				if ((filterModeMask & SIDScoreIR.FilterMode.HP.mask) != 0)
					filterModeBits |= 0x40;
				if (filterModeMask != 0)
					filterRouteMask |= (1 << (v - 1));
			}
			pw &= 0x0FFF;
			pwMin &= 0x0FFF;
			pwMax &= 0x0FFF;
			if (pwMin > pwMax) {
				int tmp = pwMin;
				pwMin = pwMax;
				pwMax = tmp;
			}
			if (pw < pwMin) pw = pwMin;
			if (pw > pwMax) pw = pwMax;

			int base = sidVoiceBase(v);
			sb.append("  lda #$" + hex2(ad) + "\n");
			sb.append("  sta $" + hex4(base + 5) + "\n");
			sb.append("  lda #$" + hex2(sr) + "\n");
			sb.append("  sta $" + hex4(base + 6) + "\n");
			sb.append("  lda #$" + hex2(pw & 0xff) + "\n");
			sb.append("  sta $" + hex4(base + 2) + "\n");
			sb.append("  lda #$" + hex2((pw >> 8) & 0xff) + "\n");
			sb.append("  sta $" + hex4(base + 3) + "\n");
			sb.append("  lda #$00\n");
			sb.append("  sta $" + hex4(base + 0) + "\n");
			sb.append("  sta $" + hex4(base + 1) + "\n");
			sb.append("  sta $" + hex4(base + 4) + "\n");

			String label = "v" + v;
			int sweepWord = pwSweep & 0xFFFF;
			sb.append("  lda #$" + hex2(ctrlBase) + "\n");
			sb.append("  sta " + label + "_ctrl\n");
			sb.append("  lda #$" + hex2(waveBits) + "\n");
			sb.append("  sta " + label + "_wave_base\n");
			sb.append("  sta " + label + "_wave_bits\n");
			sb.append("  lda #$" + hex2(pw & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_base\n");
			sb.append("  sta " + label + "_pw\n");
			sb.append("  lda #$" + hex2((pw >> 8) & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_base+1\n");
			sb.append("  sta " + label + "_pw+1\n");
			sb.append("  lda #$" + hex2(pwMin & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_min\n");
			sb.append("  lda #$" + hex2((pwMin >> 8) & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_min+1\n");
			sb.append("  lda #$" + hex2(pwMax & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_max\n");
			sb.append("  lda #$" + hex2((pwMax >> 8) & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_max+1\n");
			sb.append("  lda #$" + hex2(sweepWord & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_sweep\n");
			sb.append("  lda #$" + hex2((sweepWord >> 8) & 0xff) + "\n");
			sb.append("  sta " + label + "_pw_sweep+1\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + label + "_pw_cnt\n");
			sb.append("  sta " + label + "_pw_cnt+1\n");
			sb.append("  sta " + label + "_pw_idx\n");
			sb.append("  sta " + label + "_wave_cnt\n");
			sb.append("  sta " + label + "_wave_cnt+1\n");
			sb.append("  sta " + label + "_wave_idx\n");
			sb.append("  sta " + label + "_gate_cnt\n");
			sb.append("  sta " + label + "_gate_cnt+1\n");
			sb.append("  sta " + label + "_gate_idx\n");
			sb.append("  sta " + label + "_gate_on\n");
			sb.append("  sta " + label + "_pitch_cnt\n");
			sb.append("  sta " + label + "_pitch_cnt+1\n");
			sb.append("  sta " + label + "_pitch_idx\n");
			sb.append("  sta " + label + "_pitch_off\n");
			sb.append("  sta " + label + "_active\n");
			sb.append("  sta " + label + "_noise\n");

			int fcLo = filterCutoff & 0x07;
			int fcHi = (filterCutoff >> 3) & 0xFF;
			sb.append("  lda #$" + hex2(fcLo) + "\n");
			sb.append("  sta " + label + "_filter_base\n");
			sb.append("  sta " + label + "_filter_cutoff\n");
			sb.append("  lda #$" + hex2(fcHi) + "\n");
			sb.append("  sta " + label + "_filter_base+1\n");
			sb.append("  sta " + label + "_filter_cutoff+1\n");
			sb.append("  lda #$" + hex2((filterRes << 4) & 0xF0) + "\n");
			sb.append("  sta " + label + "_filter_res\n");
			sb.append("  lda #$" + hex2(filterModeBits & 0x70) + "\n");
			sb.append("  sta " + label + "_filter_mode\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + label + "_filter_cnt\n");
			sb.append("  sta " + label + "_filter_cnt+1\n");
			sb.append("  sta " + label + "_filter_idx\n");
		}

		sb.append("\n");
		sb.append("  lda #<v1_data\n");
		sb.append("  sta v1_ptr\n");
		sb.append("  lda #>v1_data\n");
		sb.append("  sta v1_ptr+1\n");
		sb.append("  lda #<v2_data\n");
		sb.append("  sta v2_ptr\n");
		sb.append("  lda #>v2_data\n");
		sb.append("  sta v2_ptr+1\n");
		sb.append("  lda #<v3_data\n");
		sb.append("  sta v3_ptr\n");
		sb.append("  lda #>v3_data\n");
		sb.append("  sta v3_ptr+1\n");
		sb.append("  lda #$00\n");
		sb.append("  sta v1_cnt\n");
		sb.append("  sta v1_cnt+1\n");
		sb.append("  sta v2_cnt\n");
		sb.append("  sta v2_cnt+1\n");
		sb.append("  sta v3_cnt\n");
		sb.append("  sta v3_cnt+1\n");
		sb.append("  cli\n");
		sb.append("  rts\n\n");

		if (installIrq) {
			sb.append("install_irq:\n");
			sb.append("  sei\n");
			sb.append("  lda $0314\n");
			sb.append("  sta old_irq\n");
			sb.append("  lda $0315\n");
			sb.append("  sta old_irq+1\n");
			sb.append("  lda #$7f\n");
			sb.append("  sta $dc0d\n");
			sb.append("  sta $dd0d\n");
			sb.append("  lda $dc0d\n");
			sb.append("  lda $dd0d\n");
			sb.append("  lda $d011\n");
			sb.append("  and #$7f\n");
			sb.append("  sta $d011\n");
			sb.append("  lda #$" + hex2(RASTER_LINE) + "\n");
			sb.append("  sta $d012\n");
			sb.append("  lda #$01\n");
			sb.append("  sta $d019\n");
			sb.append("  sta $d01a\n");
			sb.append("  lda #<irq\n");
			sb.append("  sta $0314\n");
			sb.append("  lda #>irq\n");
			sb.append("  sta $0315\n");
			sb.append("  cli\n");
			sb.append("  rts\n\n");

			sb.append("irq:\n");
			sb.append("  pha\n");
			sb.append("  txa\n");
			sb.append("  pha\n");
			sb.append("  tya\n");
			sb.append("  pha\n");
			sb.append("  lda $d019\n");
			sb.append("  and #$01\n");
			sb.append("  beq irq_done\n");
			sb.append("  sta $d019\n");
			sb.append("  jsr play\n");
			sb.append("irq_done:\n");
			sb.append("  pla\n");
			sb.append("  tay\n");
			sb.append("  pla\n");
			sb.append("  tax\n");
			sb.append("  pla\n");
			sb.append("  jmp (old_irq)\n\n");

			sb.append("old_irq:\n");
			sb.append("  .word 0\n\n");
		}

		sb.append("v1_ptr:\n");
		sb.append("  .word 0\n");
		sb.append("v2_ptr:\n");
		sb.append("  .word 0\n");
		sb.append("v3_ptr:\n");
		sb.append("  .word 0\n");
		sb.append("v1_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v2_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v3_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pw_base:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pw:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pw_min:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pw_max:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pw_sweep:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pw_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pw_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_ctrl:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_note_base:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_wave_base:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_wave_bits:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_wave_ctrl:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_wave_note:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_wave_mode:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_wave_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v1_wave_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_gate_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v1_gate_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_gate_on:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_pitch_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v1_pitch_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_pitch_off:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_active:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_noise:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_filter_base:\n");
		sb.append("  .word 0\n");
		sb.append("v1_filter_cutoff:\n");
		sb.append("  .word 0\n");
		sb.append("v1_filter_res:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_filter_mode:\n");
		sb.append("  .byte 0\n");
		sb.append("v1_filter_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v1_filter_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_pw_base:\n");
		sb.append("  .word 0\n");
		sb.append("v2_pw:\n");
		sb.append("  .word 0\n");
		sb.append("v2_pw_min:\n");
		sb.append("  .word 0\n");
		sb.append("v2_pw_max:\n");
		sb.append("  .word 0\n");
		sb.append("v2_pw_sweep:\n");
		sb.append("  .word 0\n");
		sb.append("v2_pw_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v2_pw_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_ctrl:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_note_base:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_wave_base:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_wave_bits:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_wave_ctrl:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_wave_note:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_wave_mode:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_wave_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v2_wave_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_gate_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v2_gate_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_gate_on:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_pitch_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v2_pitch_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_pitch_off:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_active:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_noise:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_filter_base:\n");
		sb.append("  .word 0\n");
		sb.append("v2_filter_cutoff:\n");
		sb.append("  .word 0\n");
		sb.append("v2_filter_res:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_filter_mode:\n");
		sb.append("  .byte 0\n");
		sb.append("v2_filter_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v2_filter_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_pw_base:\n");
		sb.append("  .word 0\n");
		sb.append("v3_pw:\n");
		sb.append("  .word 0\n");
		sb.append("v3_pw_min:\n");
		sb.append("  .word 0\n");
		sb.append("v3_pw_max:\n");
		sb.append("  .word 0\n");
		sb.append("v3_pw_sweep:\n");
		sb.append("  .word 0\n");
		sb.append("v3_pw_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v3_pw_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_ctrl:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_note_base:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_wave_base:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_wave_bits:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_wave_ctrl:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_wave_note:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_wave_mode:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_wave_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v3_wave_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_gate_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v3_gate_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_gate_on:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_pitch_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v3_pitch_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_pitch_off:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_active:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_noise:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_filter_base:\n");
		sb.append("  .word 0\n");
		sb.append("v3_filter_cutoff:\n");
		sb.append("  .word 0\n");
		sb.append("v3_filter_res:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_filter_mode:\n");
		sb.append("  .byte 0\n");
		sb.append("v3_filter_cnt:\n");
		sb.append("  .word 0\n");
		sb.append("v3_filter_idx:\n");
		sb.append("  .byte 0\n");
		sb.append("tmp_ptr_save:\n");
		sb.append("  .word 0\n\n");
		sb.append("tmp_byte:\n");
		sb.append("  .byte 0\n\n");

		sb.append("*=$" + hex4(PLAY_ADDR) + " \"PLAYER\"\n");
		sb.append("play:\n");
		sb.append("  lda TMP_PTR\n");
		sb.append("  sta tmp_ptr_save\n");
		sb.append("  lda TMP_PTR+1\n");
		sb.append("  sta tmp_ptr_save+1\n");
		sb.append("  jsr v1_update\n");
		sb.append("  jsr v1_gateseq_update\n");
		sb.append("  jsr v1_waveseq_update\n");
		sb.append("  jsr v1_pwm_update\n");
		sb.append("  jsr v1_pitchseq_update\n");
		sb.append("  jsr v1_filterseq_update\n");
		sb.append("  jsr v2_update\n");
		sb.append("  jsr v2_gateseq_update\n");
		sb.append("  jsr v2_waveseq_update\n");
		sb.append("  jsr v2_pwm_update\n");
		sb.append("  jsr v2_pitchseq_update\n");
		sb.append("  jsr v2_filterseq_update\n");
		sb.append("  jsr v3_update\n");
		sb.append("  jsr v3_gateseq_update\n");
		sb.append("  jsr v3_waveseq_update\n");
		sb.append("  jsr v3_pwm_update\n");
		sb.append("  jsr v3_pitchseq_update\n");
		sb.append("  jsr v3_filterseq_update\n");
		sb.append("  lda tmp_ptr_save\n");
		sb.append("  sta TMP_PTR\n");
		sb.append("  lda tmp_ptr_save+1\n");
		sb.append("  sta TMP_PTR+1\n");
		sb.append("  rts\n\n");

		appendVoiceUpdate(sb, "v1", 1);
		appendVoiceUpdate(sb, "v2", 2);
		appendVoiceUpdate(sb, "v3", 3);

		SIDScoreIR.TableIR v1Pw = resolvePwTable(score, 1);
		SIDScoreIR.TableIR v2Pw = resolvePwTable(score, 2);
		SIDScoreIR.TableIR v3Pw = resolvePwTable(score, 3);
		SIDScoreIR.TableIR v1Wave = resolveWaveTable(score, 1);
		SIDScoreIR.TableIR v2Wave = resolveWaveTable(score, 2);
		SIDScoreIR.TableIR v3Wave = resolveWaveTable(score, 3);
		SIDScoreIR.TableIR v1Gate = resolveGateTable(score, 1);
		SIDScoreIR.TableIR v2Gate = resolveGateTable(score, 2);
		SIDScoreIR.TableIR v3Gate = resolveGateTable(score, 3);
		SIDScoreIR.TableIR v1Pitch = resolvePitchTable(score, 1);
		SIDScoreIR.TableIR v2Pitch = resolvePitchTable(score, 2);
		SIDScoreIR.TableIR v3Pitch = resolvePitchTable(score, 3);
		SIDScoreIR.TableIR v1Filter = resolveFilterTable(score, 1);
		SIDScoreIR.TableIR v2Filter = resolveFilterTable(score, 2);
		SIDScoreIR.TableIR v3Filter = resolveFilterTable(score, 3);
		appendPwmUpdate(sb, "v1", 1, v1Pw);
		appendPwmUpdate(sb, "v2", 2, v2Pw);
		appendPwmUpdate(sb, "v3", 3, v3Pw);
		appendWaveSeqUpdate(sb, "v1", 1, v1Wave);
		appendWaveSeqUpdate(sb, "v2", 2, v2Wave);
		appendWaveSeqUpdate(sb, "v3", 3, v3Wave);
		appendGateSeqUpdate(sb, "v1", 1, v1Gate);
		appendGateSeqUpdate(sb, "v2", 2, v2Gate);
		appendGateSeqUpdate(sb, "v3", 3, v3Gate);
		appendPitchSeqUpdate(sb, "v1", 1, v1Pitch);
		appendPitchSeqUpdate(sb, "v2", 2, v2Pitch);
		appendPitchSeqUpdate(sb, "v3", 3, v3Pitch);
		appendApplyNote(sb, "v1", 1);
		appendApplyNote(sb, "v2", 2);
		appendApplyNote(sb, "v3", 3);
		appendFilterSeqUpdate(sb, "v1", 1, v1Filter, filterRouteMask);
		appendFilterSeqUpdate(sb, "v2", 2, v2Filter, filterRouteMask);
		appendFilterSeqUpdate(sb, "v3", 3, v3Filter, filterRouteMask);

		sb.append("*=* \"DATA\"\n");
		appendVoiceData(sb, score, 1);
		appendVoiceData(sb, score, 2);
		appendVoiceData(sb, score, 3);
		appendPwTables(sb, score);
		appendWaveTables(sb, score);
		appendGateTables(sb, score);
		appendPitchTables(sb, score);
		appendFilterTables(sb, score);
		appendNoteFreqTable(sb, score);

		Files.writeString(outAsm, sb.toString(), StandardCharsets.US_ASCII);
	}

	public ProgramStats estimateProgramStats(SIDScoreIR.TimedScore score) {
		int voiceEventBytes = 0;
		for (int voice = 1; voice <= 3; voice++) {
			SIDScoreIR.TimedVoice tv = score.voices().get(voice);
			SIDScoreIR.InstrumentIR instr = tv != null ? tv.instrument() : null;
			if (tv != null && instr != null) {
				voiceEventBytes += buildVoiceData(tv, instr, score).size();
			} else {
				voiceEventBytes += 6; // terminator-only stream
			}
		}

		int tableBytes = 0;
		for (SIDScoreIR.TableIR table : score.tables().values()) {
			int steps = table.steps().size();
			switch (table.type()) {
				case PW -> tableBytes += 2 + (steps * 4);     // count + loop + (dur,pw)
				case WAVE -> tableBytes += steps * 8;         // 8 bytes per step
				case GATE -> tableBytes += steps * 4;         // .word dur + gate + pad
				case PITCH -> tableBytes += steps * 4;        // .word dur + off + pad
				case FILTER -> tableBytes += steps * 4;       // .word dur + cutoff
				default -> {
					// not emitted by assembler backend
				}
			}
		}

		return new ProgramStats(voiceEventBytes, tableBytes, NOTE_FREQ_TABLE_BYTES);
	}

	public void assemble(Path asm, Path outPrg) throws IOException, InterruptedException {
		Path kickAssJar = resolveKickAssJar();
		if (kickAssJar == null) {
			throw new IOException("KickAssembler jar not found. Tried: " + KICKASS_JAR + " and "
					+ Path.of("net.resheim.sidscore/lib/KickAss.jar"));
		}
		List<String> cmd = List.of(
				"java",
				"-jar",
				kickAssJar.toString(),
				asm.toString(),
				"-o",
				outPrg.toString()
		);
		ProcessBuilder pb = new ProcessBuilder(cmd);
		pb.redirectErrorStream(true);
		Process p = pb.start();
		byte[] out = p.getInputStream().readAllBytes();
		int code = p.waitFor();
		if (code != 0) {
			throw new IOException("KickAssembler failed (exit " + code + "):\n" + new String(out, StandardCharsets.UTF_8));
		}
	}

	private Path resolveKickAssJar() {
		if (Files.isRegularFile(KICKASS_JAR)) {
			return KICKASS_JAR;
		}
		Path repoRelative = Path.of("net.resheim.sidscore/lib/KickAss.jar");
		if (Files.isRegularFile(repoRelative)) {
			return repoRelative;
		}
		return null;
	}

	public void writeSid(Path prg, SIDScoreIR.TimedScore score, Path outSid) throws IOException {
		writeSid(prg, score, outSid, SidModel.MOS6581, new DriverAddresses(BASIC_LOAD_ADDR, LOAD_ADDR, PLAY_ADDR));
	}

	public void writeSid(Path prg, SIDScoreIR.TimedScore score, Path outSid, SidModel model) throws IOException {
		writeSid(prg, score, outSid, model, new DriverAddresses(BASIC_LOAD_ADDR, LOAD_ADDR, PLAY_ADDR));
	}

	public void writeSid(Path prg, SIDScoreIR.TimedScore score, Path outSid, SidModel model, DriverAddresses addresses) throws IOException {
		byte[] prgBytes = Files.readAllBytes(prg);
		if (prgBytes.length < 2) {
			throw new IOException("PRG too small: " + prg);
		}
		byte[] data = prgBytes;

		DriverAddresses effective = addresses != null ? addresses : new DriverAddresses(BASIC_LOAD_ADDR, LOAD_ADDR, PLAY_ADDR);
		int prgLoadAddr = (prgBytes[0] & 0xFF) | ((prgBytes[1] & 0xFF) << 8);
		if (prgLoadAddr != effective.loadAddress()) {
			throw new IOException("PRG load address $" + hex4(prgLoadAddr)
					+ " does not match backend load address $" + hex4(effective.loadAddress()));
		}
		int initAddr = effective.initAddress();
		int playAddr = effective.playAddress();

		byte[] header = new byte[0x7C];
		writeAscii(header, 0x00, "PSID");
		write16be(header, 0x04, 2);      // version
		write16be(header, 0x06, 0x7C);   // data offset
		write16be(header, 0x08, 0);
		write16be(header, 0x0A, initAddr);
		write16be(header, 0x0C, playAddr);
		write16be(header, 0x0E, 1);      // songs
		write16be(header, 0x10, 1);      // start song
		write32be(header, 0x12, 0);      // speed: 0 = VBI

		String title = score.title().orElse("SIDScore");
		String author = score.author().orElse("SIDScore");
		String released = score.released().orElse("2026");
		writePaddedAscii(header, 0x16, title, 32);
		writePaddedAscii(header, 0x36, author, 32);
		writePaddedAscii(header, 0x56, released, 32);

		int flags = 0;
		flags |= (score.system() == SIDScoreIR.VideoSystem.PAL) ? 0x04 : 0x08;
		flags |= (model != null ? model : SidModel.MOS6581).psidFlagBits();
		write16be(header, 0x76, flags);
		header[0x78] = 0; // start page
		header[0x79] = 0; // page length
		write16be(header, 0x7A, 0); // second SID addr

		byte[] out = new byte[header.length + data.length];
		System.arraycopy(header, 0, out, 0, header.length);
		System.arraycopy(data, 0, out, header.length, data.length);
		Files.write(outSid, out);
	}

	private void appendVoiceUpdate(StringBuilder sb, String label, int voiceIndex) {
		int base = sidVoiceBase(voiceIndex);
		String cnt = label.toLowerCase() + "_cnt";
		String ptr = label.toLowerCase() + "_ptr";
		String ctrlVar = label.toLowerCase() + "_ctrl";
		String noteBase = label.toLowerCase() + "_note_base";
		String activeVar = label.toLowerCase() + "_active";
		String noiseVar = label.toLowerCase() + "_noise";

		sb.append(label + "_update:\n");
		sb.append("  lda " + cnt + "\n");
		sb.append("  ora " + cnt + "+1\n");
		sb.append("  beq " + label + "_load\n");
		sb.append("  lda " + cnt + "\n");
		sb.append("  bne " + label + "_dec_lo\n");
		sb.append("  dec " + cnt + "+1\n");
		sb.append("  lda #$ff\n");
		sb.append("  sta " + cnt + "\n");
		sb.append("  rts\n");
		sb.append(label + "_dec_lo:\n");
		sb.append("  dec " + cnt + "\n");
		sb.append("  rts\n\n");

		sb.append(label + "_load:\n");
		sb.append("  lda " + ptr + "\n");
		sb.append("  sta TMP_PTR\n");
		sb.append("  lda " + ptr + "+1\n");
		sb.append("  sta TMP_PTR+1\n");
		sb.append("  ldy #$00\n");
		sb.append("  lda (TMP_PTR),y\n");
		sb.append("  sta " + cnt + "\n");
		sb.append("  iny\n");
		sb.append("  lda (TMP_PTR),y\n");
		sb.append("  sta " + cnt + "+1\n");
		sb.append("  ora " + cnt + "\n");
		sb.append("  bne " + label + "_has_event\n");
		sb.append("  jmp " + label + "_done\n");
		sb.append(label + "_has_event:\n");
		sb.append("  iny\n");
		sb.append("  lda (TMP_PTR),y\n");
		sb.append("  sta $" + hex4(base + 0) + "\n");
		sb.append("  sta tmp_byte\n");
		sb.append("  iny\n");
		sb.append("  lda (TMP_PTR),y\n");
		sb.append("  sta $" + hex4(base + 1) + "\n");
		sb.append("  ora tmp_byte\n");
		sb.append("  sta tmp_byte\n");
		sb.append("  iny\n");
		sb.append("  lda (TMP_PTR),y\n");
		sb.append("  tax\n");
		sb.append("  and #$f7\n");
		sb.append("  sta $" + hex4(base + 4) + "\n");
		sb.append("  sta " + ctrlVar + "\n");
		sb.append("  txa\n");
		sb.append("  and #$01\n");
		sb.append("  ora tmp_byte\n");
		sb.append("  beq " + label + "_inactive\n");
		sb.append("  lda #$01\n");
		sb.append("  sta " + activeVar + "\n");
		sb.append("  jmp " + label + "_active_set\n");
		sb.append(label + "_inactive:\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + activeVar + "\n");
		sb.append(label + "_active_set:\n");
		sb.append("  txa\n");
		sb.append("  sta tmp_byte\n");
		sb.append("  iny\n");
		sb.append("  lda (TMP_PTR),y\n");
		sb.append("  sta " + noteBase + "\n");
		sb.append("  and #$80\n");
		sb.append("  beq " + label + "_not_noise\n");
		sb.append("  lda #$01\n");
		sb.append("  sta " + noiseVar + "\n");
		sb.append("  lda " + noteBase + "\n");
		sb.append("  and #$7f\n");
		sb.append("  sta " + noteBase + "\n");
		sb.append("  jmp " + label + "_noise_done\n");
		sb.append(label + "_not_noise:\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + noiseVar + "\n");
		sb.append(label + "_noise_done:\n");
		sb.append("  lda " + activeVar + "\n");
		sb.append("  bne " + label + "_active_ok\n");
		sb.append("  jsr " + label + "_pitchseq_reset\n");
		sb.append(label + "_active_ok:\n");
		sb.append("  lda tmp_byte\n");
		sb.append("  and #$01\n");
		sb.append("  beq " + label + "_pwm_no_reset\n");
		sb.append("  lda tmp_byte\n");
		sb.append("  and #$08\n");
		sb.append("  bne " + label + "_pwm_no_reset\n");
		sb.append("  jsr " + label + "_gateseq_reset\n");
		sb.append("  jsr " + label + "_waveseq_reset\n");
		sb.append("  jsr " + label + "_pwm_reset\n");
		sb.append("  jsr " + label + "_pitchseq_reset\n");
		sb.append("  jsr " + label + "_filterseq_reset\n");
		sb.append(label + "_pwm_no_reset:\n");
		sb.append("  lda tmp_byte\n");
		sb.append("  and #$01\n");
		sb.append("  beq " + label + "_note_no_apply\n");
		sb.append("  lda " + noiseVar + "\n");
		sb.append("  bne " + label + "_note_no_apply\n");
		sb.append("  jsr " + label + "_apply_note\n");
		sb.append(label + "_note_no_apply:\n");
		sb.append("  lda " + ptr + "\n");
		sb.append("  clc\n");
		sb.append("  adc #$06\n");
		sb.append("  sta " + ptr + "\n");
		sb.append("  bcc " + label + "_dec\n");
		sb.append("  inc " + ptr + "+1\n");
		sb.append(label + "_dec:\n");
		sb.append("  jmp " + label + "_dec_lo\n");
		sb.append(label + "_done:\n");
		sb.append("  lda #$00\n");
		sb.append("  sta $" + hex4(base + 4) + "\n");
		sb.append("  sta " + ctrlVar + "\n");
		sb.append("  sta " + activeVar + "\n");
		sb.append("  sta " + noiseVar + "\n");
		sb.append("  jsr " + label + "_pitchseq_reset\n");
		sb.append("  rts\n\n");
	}

	private void appendVoiceData(StringBuilder sb, SIDScoreIR.TimedScore score, int voiceIndex) {
		SIDScoreIR.TimedVoice tv = score.voices().get(voiceIndex);
		SIDScoreIR.InstrumentIR instr = tv != null ? tv.instrument() : null;

		List<Integer> bytes = new ArrayList<>();
		if (tv != null && instr != null) {
			bytes.addAll(buildVoiceData(tv, instr, score));
		} else {
			bytes.add(0);
			bytes.add(0);
			bytes.add(0);
			bytes.add(0);
			bytes.add(0);
			bytes.add(0);
		}

		sb.append("v" + voiceIndex + "_data:\n");
		for (int i = 0; i < bytes.size(); i += 16) {
			int end = Math.min(bytes.size(), i + 16);
			sb.append("  .byte ");
			for (int j = i; j < end; j++) {
				if (j > i) sb.append(", ");
				sb.append("$" + hex2(bytes.get(j)));
			}
			sb.append("\n");
		}
		sb.append("\n");
	}

	private SIDScoreIR.TableIR resolvePwTable(SIDScoreIR.TimedScore score, int voiceIndex) {
		SIDScoreIR.TimedVoice tv = score.voices().get(voiceIndex);
		if (tv == null)
			return null;
		SIDScoreIR.InstrumentIR instr = tv.instrument();
		if (instr == null || instr.pwSeq().isEmpty())
			return null;
		return score.tables().get(instr.pwSeq().get());
	}

	private SIDScoreIR.TableIR resolveWaveTable(SIDScoreIR.TimedScore score, int voiceIndex) {
		SIDScoreIR.TimedVoice tv = score.voices().get(voiceIndex);
		if (tv == null)
			return null;
		SIDScoreIR.InstrumentIR instr = tv.instrument();
		if (instr == null || instr.waveSeq().isEmpty())
			return null;
		return score.tables().get(instr.waveSeq().get());
	}

	private SIDScoreIR.TableIR resolveGateTable(SIDScoreIR.TimedScore score, int voiceIndex) {
		SIDScoreIR.TimedVoice tv = score.voices().get(voiceIndex);
		if (tv == null)
			return null;
		SIDScoreIR.InstrumentIR instr = tv.instrument();
		if (instr == null || instr.gateSeq().isEmpty())
			return null;
		return score.tables().get(instr.gateSeq().get());
	}

	private SIDScoreIR.TableIR resolvePitchTable(SIDScoreIR.TimedScore score, int voiceIndex) {
		SIDScoreIR.TimedVoice tv = score.voices().get(voiceIndex);
		if (tv == null)
			return null;
		SIDScoreIR.InstrumentIR instr = tv.instrument();
		if (instr == null || instr.pitchSeq().isEmpty())
			return null;
		return score.tables().get(instr.pitchSeq().get());
	}

	private SIDScoreIR.TableIR resolveFilterTable(SIDScoreIR.TimedScore score, int voiceIndex) {
		SIDScoreIR.TimedVoice tv = score.voices().get(voiceIndex);
		if (tv == null)
			return null;
		SIDScoreIR.InstrumentIR instr = tv.instrument();
		if (instr == null || instr.filterModeMask() == 0 || instr.filterSeq().isEmpty())
			return null;
		return score.tables().get(instr.filterSeq().get());
	}

	private static String pwTableLabel(String name) {
		return "pw_table_" + name;
	}

	private static String waveTableLabel(String name) {
		return "wave_table_" + name;
	}

	private static String gateTableLabel(String name) {
		return "gate_table_" + name;
	}

	private static String pitchTableLabel(String name) {
		return "pitch_table_" + name;
	}

	private static String filterTableLabel(String name) {
		return "filter_table_" + name;
	}

	private void appendPwmUpdate(StringBuilder sb, String label, int voiceIndex, SIDScoreIR.TableIR pwTable) {
		int base = sidVoiceBase(voiceIndex);
		String cnt = label.toLowerCase() + "_pw_cnt";
		String idx = label.toLowerCase() + "_pw_idx";
		String pw = label.toLowerCase() + "_pw";
		String pwBase = label.toLowerCase() + "_pw_base";
		String pwMin = label.toLowerCase() + "_pw_min";
		String pwMax = label.toLowerCase() + "_pw_max";
		String pwSweep = label.toLowerCase() + "_pw_sweep";
		String activeVar = label.toLowerCase() + "_active";

		sb.append(label + "_pwm_update:\n");
		sb.append("  lda " + activeVar + "\n");
		sb.append("  bne " + label + "_pwm_active\n");
		sb.append("  rts\n");
		sb.append(label + "_pwm_active:\n");
		if (pwTable != null) {
			String tableLabel = pwTableLabel(pwTable.name()) + "_data";
			int count = pwTable.steps().size();
			int loopFlag = pwTable.loop() ? 1 : 0;

			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_pwm_load\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  bne " + label + "_pwm_dec_lo\n");
			sb.append("  dec " + cnt + "+1\n");
			sb.append("  lda #$ff\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  jmp " + label + "_pwm_write\n");
			sb.append(label + "_pwm_dec_lo:\n");
			sb.append("  dec " + cnt + "\n");
			sb.append("  jmp " + label + "_pwm_write\n\n");

			sb.append(label + "_pwm_load:\n");
			sb.append("  lda " + idx + "\n");
			sb.append("  cmp #$" + hex2(count) + "\n");
			sb.append("  bcc " + label + "_pwm_load_step\n");
			sb.append("  lda #$" + hex2(loopFlag) + "\n");
			sb.append("  beq " + label + "_pwm_hold\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + idx + "\n");
			sb.append(label + "_pwm_load_step:\n");
			sb.append("  lda #<" + tableLabel + "\n");
			sb.append("  sta TMP_PTR\n");
			sb.append("  lda #>" + tableLabel + "\n");
			sb.append("  sta TMP_PTR+1\n");
			sb.append("  ldy " + idx + "\n");
			sb.append("  tya\n");
			sb.append("  asl\n");
			sb.append("  asl\n");
			sb.append("  tay\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "+1\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + pw + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + pw + "+1\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_pwm_hold\n");
			sb.append("  inc " + idx + "\n");
			sb.append("  jmp " + label + "_pwm_write\n");
			sb.append(label + "_pwm_hold:\n");
			sb.append("  lda #$" + hex2(count) + "\n");
			sb.append("  sta " + idx + "\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  sta " + cnt + "+1\n");
		} else {
			sb.append("  lda " + pwSweep + "\n");
			sb.append("  ora " + pwSweep + "+1\n");
			sb.append("  beq " + label + "_pwm_no_update\n");
			sb.append("  clc\n");
			sb.append("  lda " + pw + "\n");
			sb.append("  adc " + pwSweep + "\n");
			sb.append("  sta " + pw + "\n");
			sb.append("  lda " + pw + "+1\n");
			sb.append("  adc " + pwSweep + "+1\n");
			sb.append("  sta " + pw + "+1\n");
			sb.append("  lda " + pw + "+1\n");
			sb.append("  cmp " + pwMin + "+1\n");
			sb.append("  bcc " + label + "_pwm_set_min\n");
			sb.append("  bne " + label + "_pwm_check_max\n");
			sb.append("  lda " + pw + "\n");
			sb.append("  cmp " + pwMin + "\n");
			sb.append("  bcc " + label + "_pwm_set_min\n");
			sb.append(label + "_pwm_check_max:\n");
			sb.append("  lda " + pw + "+1\n");
			sb.append("  cmp " + pwMax + "+1\n");
			sb.append("  bcc " + label + "_pwm_write\n");
			sb.append("  bne " + label + "_pwm_set_max\n");
			sb.append("  lda " + pw + "\n");
			sb.append("  cmp " + pwMax + "\n");
			sb.append("  bcc " + label + "_pwm_write\n");
			sb.append(label + "_pwm_set_max:\n");
			sb.append("  lda " + pwMax + "\n");
			sb.append("  sta " + pw + "\n");
			sb.append("  lda " + pwMax + "+1\n");
			sb.append("  sta " + pw + "+1\n");
			sb.append("  jmp " + label + "_pwm_write\n");
			sb.append(label + "_pwm_set_min:\n");
			sb.append("  lda " + pwMin + "\n");
			sb.append("  sta " + pw + "\n");
			sb.append("  lda " + pwMin + "+1\n");
			sb.append("  sta " + pw + "+1\n");
			sb.append("  jmp " + label + "_pwm_write\n");
			sb.append(label + "_pwm_no_update:\n");
			sb.append("  rts\n\n");
		}

		sb.append(label + "_pwm_write:\n");
		sb.append("  lda " + pw + "\n");
		sb.append("  sta $" + hex4(base + 2) + "\n");
		sb.append("  lda " + pw + "+1\n");
		sb.append("  sta $" + hex4(base + 3) + "\n");
		sb.append("  rts\n\n");

		sb.append(label + "_pwm_reset:\n");
		sb.append("  lda " + pwBase + "\n");
		sb.append("  sta " + pw + "\n");
		sb.append("  lda " + pwBase + "+1\n");
		sb.append("  sta " + pw + "+1\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + cnt + "\n");
		sb.append("  sta " + cnt + "+1\n");
		sb.append("  sta " + idx + "\n");
		sb.append("  rts\n\n");
	}

	private void appendWaveSeqUpdate(StringBuilder sb, String label, int voiceIndex, SIDScoreIR.TableIR waveTable) {
		int base = sidVoiceBase(voiceIndex);
		String cnt = label.toLowerCase() + "_wave_cnt";
		String idx = label.toLowerCase() + "_wave_idx";
		String waveBits = label.toLowerCase() + "_wave_bits";
		String waveBase = label.toLowerCase() + "_wave_base";
		String waveCtrl = label.toLowerCase() + "_wave_ctrl";
		String waveNote = label.toLowerCase() + "_wave_note";
		String waveMode = label.toLowerCase() + "_wave_mode";
		String ctrl = label.toLowerCase() + "_ctrl";
		String gateOn = label.toLowerCase() + "_gate_on";
		String noteBase = label.toLowerCase() + "_note_base";
		String activeVar = label.toLowerCase() + "_active";
		String noiseVar = label.toLowerCase() + "_noise";
		String applyNote = label + "_apply_note";

		sb.append(label + "_waveseq_update:\n");
		sb.append("  lda " + activeVar + "\n");
		sb.append("  bne " + label + "_wave_active\n");
		sb.append("  rts\n");
		sb.append(label + "_wave_active:\n");
		if (waveTable != null) {
			String tableLabel = waveTableLabel(waveTable.name()) + "_data";
			int count = waveTable.steps().size();
			int loopFlag = waveTable.loop() ? 1 : 0;

			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_wave_load\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  bne " + label + "_wave_dec_lo\n");
			sb.append("  dec " + cnt + "+1\n");
			sb.append("  lda #$ff\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  jmp " + label + "_wave_write\n");
			sb.append(label + "_wave_dec_lo:\n");
			sb.append("  dec " + cnt + "\n");
			sb.append("  jmp " + label + "_wave_write\n\n");

			sb.append(label + "_wave_load:\n");
			sb.append("  lda " + idx + "\n");
			sb.append("  cmp #$" + hex2(count) + "\n");
			sb.append("  bcc " + label + "_wave_load_step\n");
			sb.append("  lda #$" + hex2(loopFlag) + "\n");
			sb.append("  beq " + label + "_wave_hold\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + idx + "\n");
			sb.append(label + "_wave_load_step:\n");
			sb.append("  lda #<" + tableLabel + "\n");
			sb.append("  sta TMP_PTR\n");
			sb.append("  lda #>" + tableLabel + "\n");
			sb.append("  sta TMP_PTR+1\n");
			sb.append("  ldy " + idx + "\n");
			sb.append("  tya\n");
			sb.append("  asl\n");
			sb.append("  asl\n");
			sb.append("  asl\n");
			sb.append("  tay\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "+1\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + waveBits + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + waveCtrl + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + waveNote + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + waveMode + "\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_wave_hold\n");
			sb.append("  inc " + idx + "\n");
			sb.append("  jmp " + label + "_wave_write\n");
			sb.append(label + "_wave_hold:\n");
			sb.append("  lda #$" + hex2(count) + "\n");
			sb.append("  sta " + idx + "\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  sta " + cnt + "+1\n");
		} else {
			sb.append("  rts\n\n");
			sb.append(label + "_waveseq_reset:\n");
			sb.append("  rts\n\n");
			return;
		}

		sb.append(label + "_wave_write:\n");
		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$80\n");
		sb.append("  beq " + label + "_wave_no_wave\n");
		sb.append("  lda " + ctrl + "\n");
		sb.append("  and #$0f\n");
		sb.append("  ora " + waveBits + "\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append(label + "_wave_no_wave:\n");

		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$02\n");
		sb.append("  beq " + label + "_wave_no_gate\n");
		sb.append("  lda " + ctrl + "\n");
		sb.append("  and #$fe\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$01\n");
		sb.append("  ora " + ctrl + "\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$01\n");
		sb.append("  sta " + gateOn + "\n");
		sb.append(label + "_wave_no_gate:\n");

		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$08\n");
		sb.append("  beq " + label + "_wave_no_ring\n");
		sb.append("  lda " + ctrl + "\n");
		sb.append("  and #$fb\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$04\n");
		sb.append("  ora " + ctrl + "\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append(label + "_wave_no_ring:\n");

		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$20\n");
		sb.append("  beq " + label + "_wave_no_sync\n");
		sb.append("  lda " + ctrl + "\n");
		sb.append("  and #$fd\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$10\n");
		sb.append("  ora " + ctrl + "\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append(label + "_wave_no_sync:\n");

		sb.append("  lda " + ctrl + "\n");
		sb.append("  sta $" + hex4(base + 4) + "\n");

		sb.append("  lda " + waveCtrl + "\n");
		sb.append("  and #$40\n");
		sb.append("  beq " + label + "_wave_no_reset\n");
		sb.append("  lda " + ctrl + "\n");
		sb.append("  ora #$08\n");
		sb.append("  sta $" + hex4(base + 4) + "\n");
		sb.append("  lda " + ctrl + "\n");
		sb.append("  sta $" + hex4(base + 4) + "\n");
		sb.append(label + "_wave_no_reset:\n");

		sb.append("  lda " + noiseVar + "\n");
		sb.append("  bne " + label + "_wave_no_note\n");
		sb.append("  lda " + waveMode + "\n");
		sb.append("  beq " + label + "_wave_no_note\n");
		sb.append("  cmp #$01\n");
		sb.append("  beq " + label + "_wave_note_abs\n");

		// relative note
		sb.append("  lda " + waveNote + "\n");
		sb.append("  tax\n");
		sb.append("  bpl " + label + "_wave_note_rel_pos\n");
		sb.append("  txa\n");
		sb.append("  eor #$ff\n");
		sb.append("  clc\n");
		sb.append("  adc #$01\n");
		sb.append("  sta tmp_byte\n");
		sb.append("  lda " + noteBase + "\n");
		sb.append("  sec\n");
		sb.append("  sbc tmp_byte\n");
		sb.append("  bcs " + label + "_wave_note_store\n");
		sb.append("  lda #$00\n");
		sb.append("  jmp " + label + "_wave_note_store\n");
		sb.append(label + "_wave_note_rel_pos:\n");
		sb.append("  txa\n");
		sb.append("  clc\n");
		sb.append("  adc " + noteBase + "\n");
		sb.append("  cmp #$80\n");
		sb.append("  bcc " + label + "_wave_note_store\n");
		sb.append("  lda #$7f\n");
		sb.append(label + "_wave_note_store:\n");
		sb.append("  sta " + noteBase + "\n");
		sb.append("  jmp " + label + "_wave_note_write\n");

		sb.append(label + "_wave_note_abs:\n");
		sb.append("  lda " + waveNote + "\n");
		sb.append("  cmp #$80\n");
		sb.append("  bcc " + label + "_wave_note_abs_ok\n");
		sb.append("  lda #$7f\n");
		sb.append(label + "_wave_note_abs_ok:\n");
		sb.append("  sta " + noteBase + "\n");

		sb.append(label + "_wave_note_write:\n");
		sb.append("  jsr " + applyNote + "\n");
		sb.append(label + "_wave_no_note:\n");
		sb.append("  rts\n\n");

		sb.append(label + "_waveseq_reset:\n");
		sb.append("  lda " + waveBase + "\n");
		sb.append("  sta " + waveBits + "\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + waveCtrl + "\n");
		sb.append("  sta " + waveNote + "\n");
		sb.append("  sta " + waveMode + "\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + cnt + "\n");
		sb.append("  sta " + cnt + "+1\n");
		sb.append("  sta " + idx + "\n");
		sb.append("  rts\n\n");
	}

	private void appendGateSeqUpdate(StringBuilder sb, String label, int voiceIndex, SIDScoreIR.TableIR gateTable) {
		int base = sidVoiceBase(voiceIndex);
		String cnt = label.toLowerCase() + "_gate_cnt";
		String idx = label.toLowerCase() + "_gate_idx";
		String gateOn = label.toLowerCase() + "_gate_on";
		String ctrl = label.toLowerCase() + "_ctrl";
		String activeVar = label.toLowerCase() + "_active";

		sb.append(label + "_gateseq_update:\n");
		sb.append("  lda " + activeVar + "\n");
		sb.append("  bne " + label + "_gate_active\n");
		sb.append("  rts\n");
		sb.append(label + "_gate_active:\n");
		if (gateTable != null) {
			String tableLabel = gateTableLabel(gateTable.name()) + "_data";
			int count = gateTable.steps().size();
			int loopFlag = gateTable.loop() ? 1 : 0;

			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_gate_load\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  bne " + label + "_gate_dec_lo\n");
			sb.append("  dec " + cnt + "+1\n");
			sb.append("  lda #$ff\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  jmp " + label + "_gate_write\n");
			sb.append(label + "_gate_dec_lo:\n");
			sb.append("  dec " + cnt + "\n");
			sb.append("  jmp " + label + "_gate_write\n\n");

			sb.append(label + "_gate_load:\n");
			sb.append("  lda " + idx + "\n");
			sb.append("  cmp #$" + hex2(count) + "\n");
			sb.append("  bcc " + label + "_gate_load_step\n");
			sb.append("  lda #$" + hex2(loopFlag) + "\n");
			sb.append("  beq " + label + "_gate_hold\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + idx + "\n");
			sb.append(label + "_gate_load_step:\n");
			sb.append("  lda #<" + tableLabel + "\n");
			sb.append("  sta TMP_PTR\n");
			sb.append("  lda #>" + tableLabel + "\n");
			sb.append("  sta TMP_PTR+1\n");
			sb.append("  ldy " + idx + "\n");
			sb.append("  tya\n");
			sb.append("  asl\n");
			sb.append("  asl\n");
			sb.append("  tay\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "+1\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + gateOn + "\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_gate_hold\n");
			sb.append("  inc " + idx + "\n");
			sb.append("  jmp " + label + "_gate_write\n");
			sb.append(label + "_gate_hold:\n");
			sb.append("  lda #$" + hex2(count) + "\n");
			sb.append("  sta " + idx + "\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  sta " + cnt + "+1\n");
		} else {
			sb.append("  rts\n\n");
			sb.append(label + "_gateseq_reset:\n");
			sb.append("  rts\n\n");
			return;
		}

		sb.append(label + "_gate_write:\n");
		sb.append("  lda " + ctrl + "\n");
		sb.append("  and #$fe\n");
		sb.append("  ora " + gateOn + "\n");
		sb.append("  sta " + ctrl + "\n");
		sb.append("  sta $" + hex4(base + 4) + "\n");
		sb.append("  rts\n\n");

		sb.append(label + "_gateseq_reset:\n");
		sb.append("  lda #$01\n");
		sb.append("  sta " + gateOn + "\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + cnt + "\n");
		sb.append("  sta " + cnt + "+1\n");
		sb.append("  sta " + idx + "\n");
		sb.append("  rts\n\n");
	}

	private void appendPitchSeqUpdate(StringBuilder sb, String label, int voiceIndex, SIDScoreIR.TableIR pitchTable) {
		String cnt = label.toLowerCase() + "_pitch_cnt";
		String idx = label.toLowerCase() + "_pitch_idx";
		String pitchOff = label.toLowerCase() + "_pitch_off";
		String activeVar = label.toLowerCase() + "_active";
		String noiseVar = label.toLowerCase() + "_noise";
		String applyNote = label + "_apply_note";

		sb.append(label + "_pitchseq_update:\n");
		sb.append("  lda " + activeVar + "\n");
		sb.append("  bne " + label + "_pitch_check_noise\n");
		sb.append("  rts\n");
		sb.append(label + "_pitch_check_noise:\n");
		sb.append("  lda " + noiseVar + "\n");
		sb.append("  beq " + label + "_pitch_active\n");
		sb.append("  rts\n");
		sb.append(label + "_pitch_active:\n");
		if (pitchTable != null) {
			String tableLabel = pitchTableLabel(pitchTable.name()) + "_data";
			int count = pitchTable.steps().size();
			int loopFlag = pitchTable.loop() ? 1 : 0;

			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_pitch_load\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  bne " + label + "_pitch_dec_lo\n");
			sb.append("  dec " + cnt + "+1\n");
			sb.append("  lda #$ff\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  rts\n");
			sb.append(label + "_pitch_dec_lo:\n");
			sb.append("  dec " + cnt + "\n");
			sb.append("  rts\n\n");

			sb.append(label + "_pitch_load:\n");
			sb.append("  lda " + idx + "\n");
			sb.append("  cmp #$" + hex2(count) + "\n");
			sb.append("  bcc " + label + "_pitch_load_step\n");
			sb.append("  lda #$" + hex2(loopFlag) + "\n");
			sb.append("  beq " + label + "_pitch_hold\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + idx + "\n");
			sb.append(label + "_pitch_load_step:\n");
			sb.append("  lda #<" + tableLabel + "\n");
			sb.append("  sta TMP_PTR\n");
			sb.append("  lda #>" + tableLabel + "\n");
			sb.append("  sta TMP_PTR+1\n");
			sb.append("  ldy " + idx + "\n");
			sb.append("  tya\n");
			sb.append("  asl\n");
			sb.append("  asl\n");
			sb.append("  tay\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "+1\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + pitchOff + "\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_pitch_hold\n");
			sb.append("  inc " + idx + "\n");
			sb.append("  jsr " + applyNote + "\n");
			sb.append("  rts\n");
			sb.append(label + "_pitch_hold:\n");
			sb.append("  lda #$" + hex2(count) + "\n");
			sb.append("  sta " + idx + "\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  sta " + cnt + "+1\n");
			sb.append("  jsr " + applyNote + "\n");
			sb.append("  rts\n");
		} else {
			sb.append("  rts\n");
		}
		sb.append(label + "_pitchseq_reset:\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + pitchOff + "\n");
		sb.append("  sta " + cnt + "\n");
		sb.append("  sta " + cnt + "+1\n");
		sb.append("  sta " + idx + "\n");
		sb.append("  rts\n\n");
	}

	private void appendApplyNote(StringBuilder sb, String label, int voiceIndex) {
		int base = sidVoiceBase(voiceIndex);
		String noteBase = label.toLowerCase() + "_note_base";
		String pitchOff = label.toLowerCase() + "_pitch_off";

		sb.append(label + "_apply_note:\n");
		sb.append("  lda " + pitchOff + "\n");
		sb.append("  bmi " + label + "_apply_note_neg\n");
		sb.append("  lda " + noteBase + "\n");
		sb.append("  clc\n");
		sb.append("  adc " + pitchOff + "\n");
		sb.append("  cmp #$80\n");
		sb.append("  bcc " + label + "_apply_note_ok\n");
		sb.append("  lda #$7f\n");
		sb.append("  bne " + label + "_apply_note_ok\n");
		sb.append(label + "_apply_note_neg:\n");
		sb.append("  lda " + pitchOff + "\n");
		sb.append("  eor #$ff\n");
		sb.append("  clc\n");
		sb.append("  adc #$01\n");
		sb.append("  sta tmp_byte\n");
		sb.append("  lda " + noteBase + "\n");
		sb.append("  sec\n");
		sb.append("  sbc tmp_byte\n");
		sb.append("  bcs " + label + "_apply_note_ok\n");
		sb.append("  lda #$00\n");
		sb.append(label + "_apply_note_ok:\n");
		sb.append("  asl\n");
		sb.append("  tay\n");
		sb.append("  lda note_freq_table,y\n");
		sb.append("  sta $" + hex4(base + 0) + "\n");
		sb.append("  iny\n");
		sb.append("  lda note_freq_table,y\n");
		sb.append("  sta $" + hex4(base + 1) + "\n");
		sb.append("  rts\n\n");
	}

	private void appendFilterSeqUpdate(StringBuilder sb, String label, int voiceIndex, SIDScoreIR.TableIR filterTable,
			int filterRouteMask) {
		String cnt = label.toLowerCase() + "_filter_cnt";
		String idx = label.toLowerCase() + "_filter_idx";
		String cutoff = label.toLowerCase() + "_filter_cutoff";
		String base = label.toLowerCase() + "_filter_base";
		String res = label.toLowerCase() + "_filter_res";
		String mode = label.toLowerCase() + "_filter_mode";

		boolean filterEnabled = ((filterRouteMask >> (voiceIndex - 1)) & 0x01) != 0;
		sb.append(label + "_filterseq_update:\n");
		if (!filterEnabled) {
			sb.append("  rts\n\n");
			sb.append(label + "_filterseq_reset:\n");
			sb.append("  rts\n\n");
			return;
		}

		if (filterTable != null) {
			String tableLabel = filterTableLabel(filterTable.name()) + "_data";
			int count = filterTable.steps().size();
			int loopFlag = filterTable.loop() ? 1 : 0;

			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_filter_load\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  bne " + label + "_filter_dec_lo\n");
			sb.append("  dec " + cnt + "+1\n");
			sb.append("  lda #$ff\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  jmp " + label + "_filter_write\n");
			sb.append(label + "_filter_dec_lo:\n");
			sb.append("  dec " + cnt + "\n");
			sb.append("  jmp " + label + "_filter_write\n\n");

			sb.append(label + "_filter_load:\n");
			sb.append("  lda " + idx + "\n");
			sb.append("  cmp #$" + hex2(count) + "\n");
			sb.append("  bcc " + label + "_filter_load_step\n");
			sb.append("  lda #$" + hex2(loopFlag) + "\n");
			sb.append("  beq " + label + "_filter_hold\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + idx + "\n");
			sb.append(label + "_filter_load_step:\n");
			sb.append("  lda #<" + tableLabel + "\n");
			sb.append("  sta TMP_PTR\n");
			sb.append("  lda #>" + tableLabel + "\n");
			sb.append("  sta TMP_PTR+1\n");
			sb.append("  ldy " + idx + "\n");
			sb.append("  tya\n");
			sb.append("  asl\n");
			sb.append("  asl\n");
			sb.append("  tay\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cnt + "+1\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cutoff + "\n");
			sb.append("  iny\n");
			sb.append("  lda (TMP_PTR),y\n");
			sb.append("  sta " + cutoff + "+1\n");
			sb.append("  lda " + cnt + "\n");
			sb.append("  ora " + cnt + "+1\n");
			sb.append("  beq " + label + "_filter_hold\n");
			sb.append("  inc " + idx + "\n");
			sb.append("  jmp " + label + "_filter_write\n");
			sb.append(label + "_filter_hold:\n");
			sb.append("  lda #$" + hex2(count) + "\n");
			sb.append("  sta " + idx + "\n");
			sb.append("  lda #$00\n");
			sb.append("  sta " + cnt + "\n");
			sb.append("  sta " + cnt + "+1\n");
		}

		sb.append(label + "_filter_write:\n");
		sb.append("  lda " + cutoff + "\n");
		sb.append("  sta SID_FCLO\n");
		sb.append("  lda " + cutoff + "+1\n");
		sb.append("  sta SID_FCHI\n");
		sb.append("  lda " + res + "\n");
		if (filterRouteMask != 0) {
			sb.append("  ora #$" + hex2(filterRouteMask & 0x07) + "\n");
		}
		sb.append("  sta SID_RESFILT\n");
		sb.append("  lda " + mode + "\n");
		sb.append("  ora #$0f\n");
		sb.append("  sta SID_VOL\n");
		sb.append("  rts\n\n");

		sb.append(label + "_filterseq_reset:\n");
		sb.append("  lda " + base + "\n");
		sb.append("  sta " + cutoff + "\n");
		sb.append("  lda " + base + "+1\n");
		sb.append("  sta " + cutoff + "+1\n");
		sb.append("  lda #$00\n");
		sb.append("  sta " + cnt + "\n");
		sb.append("  sta " + cnt + "+1\n");
		sb.append("  sta " + idx + "\n");
		sb.append("  rts\n\n");
	}

	private void appendPwTables(StringBuilder sb, SIDScoreIR.TimedScore score) {
		if (score.tables().isEmpty())
			return;
		sb.append("// PWM tables\n");
		for (SIDScoreIR.TableIR table : score.tables().values()) {
			if (table.type() != SIDScoreIR.TableType.PW)
				continue;
			String label = pwTableLabel(table.name());
			sb.append(label + "_count:\n");
			sb.append("  .byte $" + hex2(table.steps().size()) + "\n");
			sb.append(label + "_loop:\n");
			sb.append("  .byte $" + hex2(table.loop() ? 1 : 0) + "\n");
			sb.append(label + "_data:\n");
			for (SIDScoreIR.TableStepIR step : table.steps()) {
				int dur = step.hold() ? 0 : step.durationFrames();
				int pw = step.value() & 0x0FFF;
				sb.append("  .word $" + hex4(dur) + ", $" + hex4(pw) + "\n");
			}
			sb.append("\n");
		}
	}

	private void appendWaveTables(StringBuilder sb, SIDScoreIR.TimedScore score) {
		if (score.tables().isEmpty())
			return;
		sb.append("// Wave tables\n");
		for (SIDScoreIR.TableIR table : score.tables().values()) {
			if (table.type() != SIDScoreIR.TableType.WAVE)
				continue;
			String label = waveTableLabel(table.name());
			sb.append(label + "_data:\n");
			for (SIDScoreIR.TableStepIR step : table.steps()) {
				int dur = step.hold() ? 0 : step.durationFrames();
				int waveBits = waveMaskToCtrl(step.value()) & 0xF0;
				int ctrl = 0;
				if (step.waveSet())
					ctrl |= 0x80;
				if (step.gate() != SIDScoreIR.TriState.UNSET) {
					ctrl |= 0x02;
					if (step.gate() == SIDScoreIR.TriState.ON)
						ctrl |= 0x01;
				}
				if (step.ring() != SIDScoreIR.TriState.UNSET) {
					ctrl |= 0x08;
					if (step.ring() == SIDScoreIR.TriState.ON)
						ctrl |= 0x04;
				}
				if (step.sync() != SIDScoreIR.TriState.UNSET) {
					ctrl |= 0x20;
					if (step.sync() == SIDScoreIR.TriState.ON)
						ctrl |= 0x10;
				}
				if (step.reset())
					ctrl |= 0x40;

				int noteMode = switch (step.noteMode()) {
				case ABS -> 1;
				case REL -> 2;
				default -> 0;
				};
				int noteVal = step.noteValue();
				if (noteMode == 1) {
					noteVal = clampMidi(noteVal);
				} else if (noteMode == 2) {
					if (noteVal < -128)
						noteVal = -128;
					if (noteVal > 127)
						noteVal = 127;
				} else {
					noteVal = 0;
				}
				int noteByte = noteVal & 0xFF;
				sb.append("  .byte $" + hex2(dur & 0xff) + ", $" + hex2((dur >> 8) & 0xff)
						+ ", $" + hex2(waveBits) + ", $" + hex2(ctrl) + ", $" + hex2(noteByte)
						+ ", $" + hex2(noteMode) + ", $00, $00\n");
			}
			sb.append("\n");
		}
	}

	private void appendGateTables(StringBuilder sb, SIDScoreIR.TimedScore score) {
		if (score.tables().isEmpty())
			return;
		sb.append("// Gate tables\n");
		for (SIDScoreIR.TableIR table : score.tables().values()) {
			if (table.type() != SIDScoreIR.TableType.GATE)
				continue;
			String label = gateTableLabel(table.name());
			sb.append(label + "_data:\n");
			for (SIDScoreIR.TableStepIR step : table.steps()) {
				int dur = step.hold() ? 0 : step.durationFrames();
				int gate = step.value() != 0 ? 1 : 0;
				sb.append("  .word $" + hex4(dur) + ", $" + hex2(gate) + ", $00\n");
			}
			sb.append("\n");
		}
	}

	private void appendPitchTables(StringBuilder sb, SIDScoreIR.TimedScore score) {
		if (score.tables().isEmpty())
			return;
		sb.append("// Pitch tables\n");
		for (SIDScoreIR.TableIR table : score.tables().values()) {
			if (table.type() != SIDScoreIR.TableType.PITCH)
				continue;
			String label = pitchTableLabel(table.name());
			sb.append(label + "_data:\n");
			for (SIDScoreIR.TableStepIR step : table.steps()) {
				int dur = step.hold() ? 0 : step.durationFrames();
				int offset = step.value();
				if (offset < -128)
					offset = -128;
				if (offset > 127)
					offset = 127;
				int offByte = offset & 0xFF;
				sb.append("  .word $" + hex4(dur) + ", $" + hex2(offByte) + ", $00\n");
			}
			sb.append("\n");
		}
	}

	private void appendFilterTables(StringBuilder sb, SIDScoreIR.TimedScore score) {
		if (score.tables().isEmpty())
			return;
		sb.append("// Filter tables (cutoff)\n");
		for (SIDScoreIR.TableIR table : score.tables().values()) {
			if (table.type() != SIDScoreIR.TableType.FILTER)
				continue;
			String label = filterTableLabel(table.name());
			sb.append(label + "_data:\n");
			for (SIDScoreIR.TableStepIR step : table.steps()) {
				int dur = step.hold() ? 0 : step.durationFrames();
				int cutoff = step.value() & 0x07FF;
				int fcLo = cutoff & 0x07;
				int fcHi = (cutoff >> 3) & 0xFF;
				int fcWord = (fcHi << 8) | fcLo;
				sb.append("  .word $" + hex4(dur) + ", $" + hex4(fcWord) + "\n");
			}
			sb.append("\n");
		}
	}

	private void appendNoteFreqTable(StringBuilder sb, SIDScoreIR.TimedScore score) {
		sb.append("// MIDI note -> SID frequency table\n");
		sb.append("note_freq_table:\n");
		for (int midi = 0; midi < 128; midi++) {
			int freq = freqRegFromMidi(midi, score.system());
			sb.append("  .word $" + hex4(freq) + "\n");
		}
		sb.append("\n");
	}

	private List<Integer> buildVoiceData(SIDScoreIR.TimedVoice tv, SIDScoreIR.InstrumentIR instr,
								 SIDScoreIR.TimedScore score) {
		List<FrameEventCompiler.FrameEvent> events = FrameEventCompiler.compileVoice(tv, score);
		return FrameEventCompiler.toBytes(events);
	}

	private int clampMidi(int midi) {
		if (midi < 0)
			return 0;
		if (midi > 127)
			return 127;
		return midi;
	}

	private int freqRegFromMidi(int midi, SIDScoreIR.VideoSystem system) {
		double hz = 440.0 * Math.pow(2.0, (midi - 69) / 12.0);
		return freqRegFromHz(hz, system);
	}

	private int freqRegFromHz(double hz, SIDScoreIR.VideoSystem system) {
		double fclk = system == SIDScoreIR.VideoSystem.PAL ? SID_CLOCK_PAL : SID_CLOCK_NTSC;
		int reg = (int) Math.round(hz * 16777216.0 / fclk);
		if (reg < 1) reg = 1;
		if (reg > 0xFFFF) reg = 0xFFFF;
		return reg;
	}

	private int waveMaskToCtrl(int waveMask) {
		int ctrl = 0;
		if ((waveMask & SIDScoreIR.Wave.TRI.mask) != 0) ctrl |= 0x10;
		if ((waveMask & SIDScoreIR.Wave.SAW.mask) != 0) ctrl |= 0x20;
		if ((waveMask & SIDScoreIR.Wave.PULSE.mask) != 0) ctrl |= 0x40;
		if ((waveMask & SIDScoreIR.Wave.NOISE.mask) != 0) ctrl |= 0x80;
		return ctrl;
	}

	private int sidVoiceBase(int voiceIndex) {
		return switch (voiceIndex) {
			case 1 -> 0xD400;
			case 2 -> 0xD407;
			case 3 -> 0xD40E;
			default -> 0xD400;
		};
	}


	private static String hex2(int v) {
		return String.format("%02X", v & 0xff);
	}

	private static String hex4(int v) {
		return String.format("%04X", v & 0xffff);
	}

	private static void writeAscii(byte[] buf, int off, String s) {
		byte[] b = s.getBytes(StandardCharsets.US_ASCII);
		System.arraycopy(b, 0, buf, off, b.length);
	}

	private static void writePaddedAscii(byte[] buf, int off, String s, int len) {
		byte[] b = s.getBytes(StandardCharsets.US_ASCII);
		int n = Math.min(len, b.length);
		System.arraycopy(b, 0, buf, off, n);
		for (int i = n; i < len; i++) buf[off + i] = 0;
	}

	private static void write16be(byte[] buf, int off, int v) {
		buf[off] = (byte) ((v >> 8) & 0xff);
		buf[off + 1] = (byte) (v & 0xff);
	}

	private static void write32be(byte[] buf, int off, int v) {
		buf[off] = (byte) ((v >> 24) & 0xff);
		buf[off + 1] = (byte) ((v >> 16) & 0xff);
		buf[off + 2] = (byte) ((v >> 8) & 0xff);
		buf[off + 3] = (byte) (v & 0xff);
	}
}
